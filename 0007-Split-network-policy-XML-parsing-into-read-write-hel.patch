From d333adf0ffa2d0b2062658ce989ecd0ba1311df7 Mon Sep 17 00:00:00 2001
From: Oliver Scott <olivercscott@gmail.com>
Date: Thu, 15 Apr 2021 17:30:29 -0400
Subject: [PATCH 07/17] Split network policy XML parsing into read/write helper
 functions

Bug: https://issuetracker.google.com/issues/207800947
Change-Id: I360bfad4c549c24f56201164442056f842708124
(cherry picked from commit 15357070f3d6e039443c383b00c66a59b5f979ec)
(cherry picked from commit 052aba23e06a8ac1b05bbfe55f02f710c762e0ca)
Signed-off-by: Mohammad Hasan Keramat J <ikeramat@protonmail.com>
---
 .../net/NetworkPolicyManagerService.java      | 487 +++++++++---------
 1 file changed, 247 insertions(+), 240 deletions(-)

diff --git a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
index 3c244911..9fca2c38 100644
--- a/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
+++ b/services/core/java/com/android/server/net/NetworkPolicyManagerService.java
@@ -2605,187 +2605,191 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileInputStream fis = null;
         try {
             fis = mPolicyFile.openRead();
-            final TypedXmlPullParser in = Xml.resolvePullParser(fis);
-
-             // Must save the <restrict-background> tags and convert them to <uid-policy> later,
-             // to skip UIDs that were explicitly denied.
-            final SparseBooleanArray restrictBackgroundAllowedUids = new SparseBooleanArray();
-
-            int type;
-            int version = VERSION_INIT;
-            boolean insideAllowlist = false;
-            while ((type = in.next()) != END_DOCUMENT) {
-                final String tag = in.getName();
-                if (type == START_TAG) {
-                    if (TAG_POLICY_LIST.equals(tag)) {
-                        final boolean oldValue = mRestrictBackground;
-                        version = readIntAttribute(in, ATTR_VERSION);
-                        mLoadedRestrictBackground = (version >= VERSION_ADDED_RESTRICT_BACKGROUND)
-                                && readBooleanAttribute(in, ATTR_RESTRICT_BACKGROUND);
-                    } else if (TAG_NETWORK_POLICY.equals(tag)) {
-                        int templateType = readIntAttribute(in, ATTR_NETWORK_TEMPLATE);
-                        final String subscriberId = in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
-                        final String networkId;
-                        final int subscriberIdMatchRule;
-                        final int templateMeteredness;
-                        if (version >= VERSION_ADDED_NETWORK_ID) {
-                            networkId = in.getAttributeValue(null, ATTR_NETWORK_ID);
-                        } else {
-                            networkId = null;
-                        }
+            readPolicyXml(fis);
 
-                        if (version >= VERSION_SUPPORTED_CARRIER_USAGE) {
-                            subscriberIdMatchRule = readIntAttribute(in,
-                                    ATTR_SUBSCRIBER_ID_MATCH_RULE);
-                            templateMeteredness = readIntAttribute(in, ATTR_TEMPLATE_METERED);
+        } catch (FileNotFoundException e) {
+            // missing policy is okay, probably first boot
+            upgradeDefaultBackgroundDataUL();
+        } catch (Exception e) {
+            Log.wtf(TAG, "problem reading network policy", e);
+        } finally {
+            IoUtils.closeQuietly(fis);
+        }
+    }
 
-                        } else {
-                            subscriberIdMatchRule =
-                                    NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT;
-                            if (templateType == MATCH_MOBILE) {
-                                Log.d(TAG, "Update template match rule from mobile to carrier and"
-                                        + " force to metered");
-                                templateType = MATCH_CARRIER;
-                                templateMeteredness = METERED_YES;
-                            } else {
-                                templateMeteredness = METERED_ALL;
-                            }
-                        }
-                        final RecurrenceRule cycleRule;
-                        if (version >= VERSION_ADDED_CYCLE) {
-                            final String start = readStringAttribute(in, ATTR_CYCLE_START);
-                            final String end = readStringAttribute(in, ATTR_CYCLE_END);
-                            final String period = readStringAttribute(in, ATTR_CYCLE_PERIOD);
-                            cycleRule = new RecurrenceRule(
-                                    RecurrenceRule.convertZonedDateTime(start),
-                                    RecurrenceRule.convertZonedDateTime(end),
-                                    RecurrenceRule.convertPeriod(period));
-                        } else {
-                            final int cycleDay = readIntAttribute(in, ATTR_CYCLE_DAY);
-                            final String cycleTimezone;
-                            if (version >= VERSION_ADDED_TIMEZONE) {
-                                cycleTimezone = in.getAttributeValue(null, ATTR_CYCLE_TIMEZONE);
-                            } else {
-                                cycleTimezone = "UTC";
-                            }
-                            cycleRule = NetworkPolicy.buildRule(cycleDay, ZoneId.of(cycleTimezone));
-                        }
-                        final long warningBytes = readLongAttribute(in, ATTR_WARNING_BYTES);
-                        final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES);
-                        final long lastLimitSnooze;
-                        if (version >= VERSION_SPLIT_SNOOZE) {
-                            lastLimitSnooze = readLongAttribute(in, ATTR_LAST_LIMIT_SNOOZE);
-                        } else if (version >= VERSION_ADDED_SNOOZE) {
-                            lastLimitSnooze = readLongAttribute(in, ATTR_LAST_SNOOZE);
-                        } else {
-                            lastLimitSnooze = SNOOZE_NEVER;
-                        }
-                        final boolean metered;
-                        if (version >= VERSION_ADDED_METERED) {
-                            metered = readBooleanAttribute(in, ATTR_METERED);
-                        } else {
-                            switch (templateType) {
-                                case MATCH_MOBILE:
-                                    metered = true;
-                                    break;
-                                default:
-                                    metered = false;
-                            }
-                        }
-                        final long lastWarningSnooze;
-                        if (version >= VERSION_SPLIT_SNOOZE) {
-                            lastWarningSnooze = readLongAttribute(in, ATTR_LAST_WARNING_SNOOZE);
-                        } else {
-                            lastWarningSnooze = SNOOZE_NEVER;
-                        }
-                        final boolean inferred;
-                        if (version >= VERSION_ADDED_INFERRED) {
-                            inferred = readBooleanAttribute(in, ATTR_INFERRED);
-                        } else {
-                            inferred = false;
-                        }
-                        final NetworkTemplate.Builder builder =
-                                new NetworkTemplate.Builder(templateType)
-                                        .setMeteredness(templateMeteredness);
-                        if (subscriberIdMatchRule
-                                == NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT) {
-                            final ArraySet<String> ids = new ArraySet<>();
-                            ids.add(subscriberId);
-                            builder.setSubscriberIds(ids);
-                        }
-                        if (networkId != null) {
-                            builder.setWifiNetworkKeys(Set.of(networkId));
-                        }
-                        final NetworkTemplate template = builder.build();
-                        if (NetworkPolicy.isTemplatePersistable(template)) {
-                            mNetworkPolicy.put(template, new NetworkPolicy(template, cycleRule,
-                                    warningBytes, limitBytes, lastWarningSnooze,
-                                    lastLimitSnooze, metered, inferred));
-                        }
-                    } else if (TAG_UID_POLICY.equals(tag)) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        final int policy = readIntAttribute(in, ATTR_POLICY);
+    private void readPolicyXml(FileInputStream fis) {
+        final TypedXmlPullParser in = Xml.resolvePullParser(fis);
+
+        // Must save the <restrict-background> tags and convert them to <uid-policy> later,
+        // to skip UIDs that were explicitly denied.
+        final SparseBooleanArray restrictBackgroundAllowedUids = new SparseBooleanArray();
+
+        int type;
+        int version = VERSION_INIT;
+        boolean insideAllowlist = false;
+        while ((type = in.next()) != END_DOCUMENT) {
+            final String tag = in.getName();
+            if (type == START_TAG) {
+                if (TAG_POLICY_LIST.equals(tag)) {
+                    final boolean oldValue = mRestrictBackground;
+                    version = readIntAttribute(in, ATTR_VERSION);
+                    mLoadedRestrictBackground = (version >= VERSION_ADDED_RESTRICT_BACKGROUND)
+                            && readBooleanAttribute(in, ATTR_RESTRICT_BACKGROUND);
+                } else if (TAG_NETWORK_POLICY.equals(tag)) {
+                    int templateType = readIntAttribute(in, ATTR_NETWORK_TEMPLATE);
+                    final String subscriberId = in.getAttributeValue(null, ATTR_SUBSCRIBER_ID);
+                    final String networkId;
+                    final int subscriberIdMatchRule;
+                    final int templateMeteredness;
+                    if (version >= VERSION_ADDED_NETWORK_ID) {
+                        networkId = in.getAttributeValue(null, ATTR_NETWORK_ID);
+                    } else {
+                        networkId = null;
+                    }
 
-                        if (UserHandle.isApp(uid)) {
-                            setUidPolicyUncheckedUL(uid, policy, false);
+                    if (version >= VERSION_SUPPORTED_CARRIER_USAGE) {
+                        subscriberIdMatchRule = readIntAttribute(in,
+                                ATTR_SUBSCRIBER_ID_MATCH_RULE);
+                        templateMeteredness = readIntAttribute(in, ATTR_TEMPLATE_METERED);
+
+                    } else {
+                        subscriberIdMatchRule =
+                                NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT;
+                        if (templateType == MATCH_MOBILE) {
+                            Log.d(TAG, "Update template match rule from mobile to carrier and"
+                                    + " force to metered");
+                            templateType = MATCH_CARRIER;
+                            templateMeteredness = METERED_YES;
                         } else {
-                            Slog.w(TAG, "unable to apply policy to UID " + uid + "; ignoring");
+                            templateMeteredness = METERED_ALL;
                         }
-                    } else if (TAG_APP_POLICY.equals(tag)) {
-                        final int appId = readIntAttribute(in, ATTR_APP_ID);
-                        final int policy = readIntAttribute(in, ATTR_POLICY);
-
-                        // TODO: set for other users during upgrade
-                        // app policy is deprecated so this is only used in pre system user split.
-                        final int uid = UserHandle.getUid(UserHandle.USER_SYSTEM, appId);
-                        if (UserHandle.isApp(uid)) {
-                            setUidPolicyUncheckedUL(uid, policy, false);
+                    }
+                    final RecurrenceRule cycleRule;
+                    if (version >= VERSION_ADDED_CYCLE) {
+                        final String start = readStringAttribute(in, ATTR_CYCLE_START);
+                        final String end = readStringAttribute(in, ATTR_CYCLE_END);
+                        final String period = readStringAttribute(in, ATTR_CYCLE_PERIOD);
+                        cycleRule = new RecurrenceRule(
+                                RecurrenceRule.convertZonedDateTime(start),
+                                RecurrenceRule.convertZonedDateTime(end),
+                                RecurrenceRule.convertPeriod(period));
+                    } else {
+                        final int cycleDay = readIntAttribute(in, ATTR_CYCLE_DAY);
+                        final String cycleTimezone;
+                        if (version >= VERSION_ADDED_TIMEZONE) {
+                            cycleTimezone = in.getAttributeValue(null, ATTR_CYCLE_TIMEZONE);
                         } else {
-                            Slog.w(TAG, "unable to apply policy to UID " + uid + "; ignoring");
+                            cycleTimezone = "UTC";
                         }
-                    } else if (TAG_WHITELIST.equals(tag)) {
-                        insideAllowlist = true;
-                    } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        restrictBackgroundAllowedUids.append(uid, true);
-                    } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
-                        final int uid = readIntAttribute(in, ATTR_UID);
-                        mRestrictBackgroundAllowlistRevokedUids.put(uid, true);
+                        cycleRule = NetworkPolicy.buildRule(cycleDay, ZoneId.of(cycleTimezone));
                     }
-                } else if (type == END_TAG) {
-                    if (TAG_WHITELIST.equals(tag)) {
-                        insideAllowlist = false;
+                    final long warningBytes = readLongAttribute(in, ATTR_WARNING_BYTES);
+                    final long limitBytes = readLongAttribute(in, ATTR_LIMIT_BYTES);
+                    final long lastLimitSnooze;
+                    if (version >= VERSION_SPLIT_SNOOZE) {
+                        lastLimitSnooze = readLongAttribute(in, ATTR_LAST_LIMIT_SNOOZE);
+                    } else if (version >= VERSION_ADDED_SNOOZE) {
+                        lastLimitSnooze = readLongAttribute(in, ATTR_LAST_SNOOZE);
+                    } else {
+                        lastLimitSnooze = SNOOZE_NEVER;
                     }
+                    final boolean metered;
+                    if (version >= VERSION_ADDED_METERED) {
+                        metered = readBooleanAttribute(in, ATTR_METERED);
+                    } else {
+                        switch (templateType) {
+                            case MATCH_MOBILE:
+                                metered = true;
+                                break;
+                            default:
+                                metered = false;
+                        }
+                    }
+                    final long lastWarningSnooze;
+                    if (version >= VERSION_SPLIT_SNOOZE) {
+                        lastWarningSnooze = readLongAttribute(in, ATTR_LAST_WARNING_SNOOZE);
+                    } else {
+                        lastWarningSnooze = SNOOZE_NEVER;
+                    }
+                    final boolean inferred;
+                    if (version >= VERSION_ADDED_INFERRED) {
+                        inferred = readBooleanAttribute(in, ATTR_INFERRED);
+                    } else {
+                        inferred = false;
+                    }
+                    final NetworkTemplate.Builder builder =
+                            new NetworkTemplate.Builder(templateType)
+                                    .setMeteredness(templateMeteredness);
+                    if (subscriberIdMatchRule
+                            == NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT) {
+                        final ArraySet<String> ids = new ArraySet<>();
+                        ids.add(subscriberId);
+                        builder.setSubscriberIds(ids);
+                    }
+                    if (networkId != null) {
+                        builder.setWifiNetworkKeys(Set.of(networkId));
+                    }
+                    final NetworkTemplate template = builder.build();
+                    if (NetworkPolicy.isTemplatePersistable(template)) {
+                        mNetworkPolicy.put(template, new NetworkPolicy(template, cycleRule,
+                                warningBytes, limitBytes, lastWarningSnooze,
+                                lastLimitSnooze, metered, inferred));
+                    }
+                } else if (TAG_UID_POLICY.equals(tag)) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    final int policy = readIntAttribute(in, ATTR_POLICY);
 
+                    if (UserHandle.isApp(uid)) {
+                        setUidPolicyUncheckedUL(uid, policy, false);
+                    } else {
+                        Slog.w(TAG, "unable to apply policy to UID " + uid + "; ignoring");
+                    }
+                } else if (TAG_APP_POLICY.equals(tag)) {
+                    final int appId = readIntAttribute(in, ATTR_APP_ID);
+                    final int policy = readIntAttribute(in, ATTR_POLICY);
+
+                    // TODO: set for other users during upgrade
+                    // app policy is deprecated so this is only used in pre system user split.
+                    final int uid = UserHandle.getUid(UserHandle.USER_SYSTEM, appId);
+                    if (UserHandle.isApp(uid)) {
+                        setUidPolicyUncheckedUL(uid, policy, false);
+                    } else {
+                        Slog.w(TAG, "unable to apply policy to UID " + uid + "; ignoring");
+                    }
+                } else if (TAG_WHITELIST.equals(tag)) {
+                    insideAllowlist = true;
+                } else if (TAG_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    restrictBackgroundAllowedUids.append(uid, true);
+                } else if (TAG_REVOKED_RESTRICT_BACKGROUND.equals(tag) && insideAllowlist) {
+                    final int uid = readIntAttribute(in, ATTR_UID);
+                    mRestrictBackgroundAllowlistRevokedUids.put(uid, true);
                 }
-            }
-
-            final int size = restrictBackgroundAllowedUids.size();
-            for (int i = 0; i < size; i++) {
-                final int uid = restrictBackgroundAllowedUids.keyAt(i);
-                final int policy = mUidPolicy.get(uid, POLICY_NONE);
-                if ((policy & POLICY_REJECT_METERED_BACKGROUND) != 0) {
-                    Slog.w(TAG, "ignoring restrict-background-allowlist for " + uid
-                            + " because its policy is " + uidPoliciesToString(policy));
-                    continue;
-                }
-                if (UserHandle.isApp(uid)) {
-                    final int newPolicy = policy | POLICY_ALLOW_METERED_BACKGROUND;
-                    if (LOGV)
-                        Log.v(TAG, "new policy for " + uid + ": " + uidPoliciesToString(newPolicy));
-                    setUidPolicyUncheckedUL(uid, newPolicy, false);
-                } else {
-                    Slog.w(TAG, "unable to update policy on UID " + uid);
+            } else if (type == END_TAG) {
+                if (TAG_WHITELIST.equals(tag)) {
+                    insideAllowlist = false;
                 }
+
             }
+        }
 
-        } catch (FileNotFoundException e) {
-            // missing policy is okay, probably first boot
-            upgradeDefaultBackgroundDataUL();
-        } catch (Exception e) {
-            Log.wtf(TAG, "problem reading network policy", e);
-        } finally {
-            IoUtils.closeQuietly(fis);
+        final int size = restrictBackgroundAllowedUids.size();
+        for (int i = 0; i < size; i++) {
+            final int uid = restrictBackgroundAllowedUids.keyAt(i);
+            final int policy = mUidPolicy.get(uid, POLICY_NONE);
+            if ((policy & POLICY_REJECT_METERED_BACKGROUND) != 0) {
+                Slog.w(TAG, "ignoring restrict-background-allowlist for " + uid
+                        + " because its policy is " + uidPoliciesToString(policy));
+                continue;
+            }
+            if (UserHandle.isApp(uid)) {
+                final int newPolicy = policy | POLICY_ALLOW_METERED_BACKGROUND;
+                if (LOGV)
+                    Log.v(TAG, "new policy for " + uid + ": " + uidPoliciesToString(newPolicy));
+                setUidPolicyUncheckedUL(uid, newPolicy, false);
+            } else {
+                Slog.w(TAG, "unable to update policy on UID " + uid);
+            }
         }
     }
 
@@ -2866,90 +2870,93 @@ public class NetworkPolicyManagerService extends INetworkPolicyManager.Stub {
         FileOutputStream fos = null;
         try {
             fos = mPolicyFile.startWrite();
+            writePolicyXml(fos);
 
-            TypedXmlSerializer out = Xml.resolveSerializer(fos);
-            out.startDocument(null, true);
-
-            out.startTag(null, TAG_POLICY_LIST);
-            writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);
-            writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);
+            mPolicyFile.finishWrite(fos);
+        } catch (IOException e) {
+            if (fos != null) {
+                mPolicyFile.failWrite(fos);
+            }
+        }
+    }
 
-            // write all known network policies
-            for (int i = 0; i < mNetworkPolicy.size(); i++) {
-                final NetworkPolicy policy = mNetworkPolicy.valueAt(i);
-                final NetworkTemplate template = policy.template;
-                if (!NetworkPolicy.isTemplatePersistable(template)) continue;
+    private void writePolicyXml(FileOutputStream fos) {
+        TypedXmlSerializer out = Xml.resolveSerializer(fos);
+        out.startDocument(null, true);
 
-                out.startTag(null, TAG_NETWORK_POLICY);
-                writeIntAttribute(out, ATTR_NETWORK_TEMPLATE, template.getMatchRule());
-                final String subscriberId = template.getSubscriberIds().isEmpty() ? null
-                        : template.getSubscriberIds().iterator().next();
-                if (subscriberId != null) {
-                    out.attribute(null, ATTR_SUBSCRIBER_ID, subscriberId);
-                }
-                final int subscriberIdMatchRule = template.getSubscriberIds().isEmpty()
-                        ? NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_ALL
-                        : NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT;
-                writeIntAttribute(out, ATTR_SUBSCRIBER_ID_MATCH_RULE, subscriberIdMatchRule);
-                if (!template.getWifiNetworkKeys().isEmpty()) {
-                    out.attribute(null, ATTR_NETWORK_ID,
-                            template.getWifiNetworkKeys().iterator().next());
-                }
-                writeIntAttribute(out, ATTR_TEMPLATE_METERED,
-                        template.getMeteredness());
-                writeStringAttribute(out, ATTR_CYCLE_START,
-                        RecurrenceRule.convertZonedDateTime(policy.cycleRule.start));
-                writeStringAttribute(out, ATTR_CYCLE_END,
-                        RecurrenceRule.convertZonedDateTime(policy.cycleRule.end));
-                writeStringAttribute(out, ATTR_CYCLE_PERIOD,
-                        RecurrenceRule.convertPeriod(policy.cycleRule.period));
-                writeLongAttribute(out, ATTR_WARNING_BYTES, policy.warningBytes);
-                writeLongAttribute(out, ATTR_LIMIT_BYTES, policy.limitBytes);
-                writeLongAttribute(out, ATTR_LAST_WARNING_SNOOZE, policy.lastWarningSnooze);
-                writeLongAttribute(out, ATTR_LAST_LIMIT_SNOOZE, policy.lastLimitSnooze);
-                writeBooleanAttribute(out, ATTR_METERED, policy.metered);
-                writeBooleanAttribute(out, ATTR_INFERRED, policy.inferred);
-                out.endTag(null, TAG_NETWORK_POLICY);
-            }
-
-            // write all known uid policies
-            for (int i = 0; i < mUidPolicy.size(); i++) {
-                final int uid = mUidPolicy.keyAt(i);
-                final int policy = mUidPolicy.valueAt(i);
+        out.startTag(null, TAG_POLICY_LIST);
+        writeIntAttribute(out, ATTR_VERSION, VERSION_LATEST);
+        writeBooleanAttribute(out, ATTR_RESTRICT_BACKGROUND, mRestrictBackground);
 
-                // skip writing empty policies
-                if (policy == POLICY_NONE) continue;
+        // write all known network policies
+        for (int i = 0; i < mNetworkPolicy.size(); i++) {
+            final NetworkPolicy policy = mNetworkPolicy.valueAt(i);
+            final NetworkTemplate template = policy.template;
+            if (!NetworkPolicy.isTemplatePersistable(template)) continue;
+
+            out.startTag(null, TAG_NETWORK_POLICY);
+            writeIntAttribute(out, ATTR_NETWORK_TEMPLATE, template.getMatchRule());
+            final String subscriberId = template.getSubscriberIds().isEmpty() ? null
+                    : template.getSubscriberIds().iterator().next();
+            if (subscriberId != null) {
+                out.attribute(null, ATTR_SUBSCRIBER_ID, subscriberId);
+            }
+            final int subscriberIdMatchRule = template.getSubscriberIds().isEmpty()
+                    ? NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_ALL
+                    : NetworkStatsUtils.SUBSCRIBER_ID_MATCH_RULE_EXACT;
+            writeIntAttribute(out, ATTR_SUBSCRIBER_ID_MATCH_RULE, subscriberIdMatchRule);
+            if (!template.getWifiNetworkKeys().isEmpty()) {
+                out.attribute(null, ATTR_NETWORK_ID,
+                        template.getWifiNetworkKeys().iterator().next());
+            }
+            writeIntAttribute(out, ATTR_TEMPLATE_METERED,
+                    template.getMeteredness());
+            writeStringAttribute(out, ATTR_CYCLE_START,
+                    RecurrenceRule.convertZonedDateTime(policy.cycleRule.start));
+            writeStringAttribute(out, ATTR_CYCLE_END,
+                    RecurrenceRule.convertZonedDateTime(policy.cycleRule.end));
+            writeStringAttribute(out, ATTR_CYCLE_PERIOD,
+                    RecurrenceRule.convertPeriod(policy.cycleRule.period));
+            writeLongAttribute(out, ATTR_WARNING_BYTES, policy.warningBytes);
+            writeLongAttribute(out, ATTR_LIMIT_BYTES, policy.limitBytes);
+            writeLongAttribute(out, ATTR_LAST_WARNING_SNOOZE, policy.lastWarningSnooze);
+            writeLongAttribute(out, ATTR_LAST_LIMIT_SNOOZE, policy.lastLimitSnooze);
+            writeBooleanAttribute(out, ATTR_METERED, policy.metered);
+            writeBooleanAttribute(out, ATTR_INFERRED, policy.inferred);
+            out.endTag(null, TAG_NETWORK_POLICY);
+        }
+
+        // write all known uid policies
+        for (int i = 0; i < mUidPolicy.size(); i++) {
+            final int uid = mUidPolicy.keyAt(i);
+            final int policy = mUidPolicy.valueAt(i);
 
-                out.startTag(null, TAG_UID_POLICY);
-                writeIntAttribute(out, ATTR_UID, uid);
-                writeIntAttribute(out, ATTR_POLICY, policy);
-                out.endTag(null, TAG_UID_POLICY);
-            }
+            // skip writing empty policies
+            if (policy == POLICY_NONE) continue;
 
-            out.endTag(null, TAG_POLICY_LIST);
+            out.startTag(null, TAG_UID_POLICY);
+            writeIntAttribute(out, ATTR_UID, uid);
+            writeIntAttribute(out, ATTR_POLICY, policy);
+            out.endTag(null, TAG_UID_POLICY);
+        }
 
-            // write all allowlists
-            out.startTag(null, TAG_WHITELIST);
+        out.endTag(null, TAG_POLICY_LIST);
 
-            // revoked restrict background allowlist
-            int size = mRestrictBackgroundAllowlistRevokedUids.size();
-            for (int i = 0; i < size; i++) {
-                final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);
-                out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-                writeIntAttribute(out, ATTR_UID, uid);
-                out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
-            }
+        // write all allowlists
+        out.startTag(null, TAG_WHITELIST);
 
-            out.endTag(null, TAG_WHITELIST);
+        // revoked restrict background allowlist
+        int size = mRestrictBackgroundAllowlistRevokedUids.size();
+        for (int i = 0; i < size; i++) {
+            final int uid = mRestrictBackgroundAllowlistRevokedUids.keyAt(i);
+            out.startTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+            writeIntAttribute(out, ATTR_UID, uid);
+            out.endTag(null, TAG_REVOKED_RESTRICT_BACKGROUND);
+        }
 
-            out.endDocument();
+        out.endTag(null, TAG_WHITELIST);
 
-            mPolicyFile.finishWrite(fos);
-        } catch (IOException e) {
-            if (fos != null) {
-                mPolicyFile.failWrite(fos);
-            }
-        }
+        out.endDocument();
     }
 
     @Override
-- 
2.41.0

